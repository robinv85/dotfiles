# ==================================================================
#
# ~/.bash_prompt
#
# ==================================================================

# Check color mode and set to 256 colors
if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
  export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
  export TERM=xterm-256color
fi

bold=$(tput bold)
underline=$(tput 0 1)
info=${bldwht}*${txtrst}

# Color definitions
if tput setaf 1 &> /dev/null; then
  tput sgr 0 0
  if [[ $(tput colors) -ge 256 ]] 2</dev/null; then
    r=$(tput setaf 124)
    g=$(tput setaf 64)
    b=$(tput setaf 33)
    c=$(tput setaf 37)
    m=$(tput setaf 125)
    y=$(tput setaf 190)
    w=$(tput setaf 7)
    o=$(tput setaf 136)
  else
    r=$(tput setaf 1)
    g=$(tput setaf 2)
    b=$(tput setaf 4)
    c=$(tput setaf 6)
    m=$(tput setaf 5)
    y=(tput setaf 3)
    k=(tput setaf 8)
    w=(tput setaf 7)
fi
else
 g="\033[1;32m"
 m="\033[1;31m"
 w="\033[1;37m"
 o="\033[;33m"
fi


parse_git_dirty () {
    [[ $(git status 2> /dev/null | tail -n1) != "nothing to commit
    (working directory clean)" ]] && echo "*"
}
parse_git_branch () {
    git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/*
    \(.*\)/\1$(parse_git_dirty)/"
}

is_git_repo() {
    $(git rev-parse --is-inside-work-tree &> /dev/null)
}

is_git_dir() {
    $(git rev-parse --is-inside-git-dir 2> /dev/null)
}

get_git_branch() {
    local branch_name

    # Get the short symbolic ref
    branch_name=$(git symbolic-ref --quiet --short HEAD 2> /dev/null) ||
    # If HEAD isn't a symbolic ref, get the short SHA
    branch_name=$(git rev-parse --short HEAD 2> /dev/null) ||
    # Otherwise, just give up
    branch_name="(unknown)"

    printf $branch_name
}

# Git status information
prompt_git() {
    local git_info git_state uc us ut st

    if ! is_git_repo || is_git_dir; then
        return 1
    fi

    git_info=$(get_git_branch)

    # Check for uncommitted changes in the index
    if ! $(git diff --quiet --ignore-submodules --cached); then
        uc="+"
    fi

    # Check for unstaged changes
    if ! $(git diff-files --quiet --ignore-submodules --); then
        us="!"
    fi

    # Check for untracked files
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        ut="?"
    fi

    # Check for stashed files
    if $(git rev-parse --verify refs/stash &>/dev/null); then
        st="$"
    fi

    git_state=$uc$us$ut$st

    # Combine the branch name and state information
    if [[ $git_state ]]; then
        git_info="$git_info[$git_state]"
    fi

    printf "${w} on ${g}${git_info}"
}


# Customize Bash prompt
build_prompt()  {
  username="${c}\\u"
  at="${w}@"
  host="${o}\\h"
  path="${b}\\W"
}

PS1="\n $username$at$host${w}: $path$(prompt_git) \n \$ ${w}"

build_prompt
export PS1
